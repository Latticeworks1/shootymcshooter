<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Multiplayer Voxel FPS</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
            cursor: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #health-bar {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600, #ffff00);
            transition: width 0.3s ease;
            width: 100%;
        }
        
        #ammo-counter {
            position: absolute;
            bottom: 50px;
            right: 50px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
        }
        
        #crosshair::before {
            width: 2px;
            height: 8px;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 8px;
            height: 2px;
            top: 50%;
            left: 4px;
            transform: translateY(-50%);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #connection-status {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            color: white;
            z-index: 1000;
            transition: all 0.3s ease;
            opacity: 0;
        }
        
        canvas {
            display: block;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading Multiplayer Voxel World...</div>
        <div id="progress">0%</div>
        <div style="font-size: 14px; margin-top: 10px;">Connecting to server...</div>
    </div>
    
    <div id="container">
        <div id="hud">
            <div id="connection-status"></div>
            <div id="crosshair"></div>
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <div id="ammo-counter">
                <div>Ammo: <span id="ammo">30</span>/<span id="total-ammo">120</span></div>
                <div>Players: <span id="player-count">1</span></div>
                <div>Score: <span id="score">0</span></div>
            </div>
        </div>
        
        <div id="stats">
            <div id="fps">FPS: --</div>
            <div id="chunks">Chunks: --</div>
            <div id="position">Position: --</div>
            <div id="network">Network: Connecting...</div>
        </div>
        
        <div id="controls">
            <strong>Controls:</strong><br>
            WASD - Move<br>
            Mouse - Look<br>
            Click - Shoot<br>
            Space - Jump<br>
            R - Reload<br>
            <br>
            <small>Click to start</small>
        </div>
    </div>

    <!-- Socket.IO Client -->
    <script src="/socket.io/socket.io.js"></script>
    
    <!-- Three.js via CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Game Configuration
        const CONFIG = {
            CHUNK_SIZE: 32,
            WORLD_HEIGHT: 64,
            RENDER_DISTANCE: 3,
            PLAYER_HEIGHT: 1.8,
            PLAYER_SPEED: 8,
            JUMP_VELOCITY: 12,
            GRAVITY: -25,
            BULLET_SPEED: 50,
            BULLET_DAMAGE: 25,
            MAX_HEALTH: 100,
            AMMO_CAPACITY: 30,
            TOTAL_AMMO: 120,
            BULLET_GRAVITY: -15
        };

        // Block Types
        const BLOCK_TYPES = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WATER: 4,
            SAND: 5,
            SNOW: 6,
            TREE: 7
        };

        // Global Game State
        const gameState = {
            health: CONFIG.MAX_HEALTH,
            ammo: CONFIG.AMMO_CAPACITY,
            totalAmmo: CONFIG.TOTAL_AMMO,
            score: 0,
            bullets: [],
            chunks: new Map(),
            loadedChunks: new Set(),
            terrainCache: new Map(),
            playerId: null,
            players: new Map(),
            isConnected: false,
            lastUIUpdate: {
                health: CONFIG.MAX_HEALTH,
                ammo: CONFIG.AMMO_CAPACITY,
                totalAmmo: CONFIG.TOTAL_AMMO,
                score: 0,
                playerCount: 1
            }
        };

        // Initialize Three.js Scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 50, 300);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            powerPreference: "high-performance",
            alpha: false
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87ceeb, 1);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        document.getElementById('container').appendChild(renderer.domElement);

        // Pointer Lock Controls
        const controls = new PointerLockControls(camera, renderer.domElement);
        scene.add(controls.getObject());
        camera.position.set(0, 50, 0);

        // Lighting Setup
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Block Materials
        const blockMaterials = {
            [BLOCK_TYPES.GRASS]: new THREE.MeshLambertMaterial({ color: 0x4a7c49 }),
            [BLOCK_TYPES.DIRT]: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            [BLOCK_TYPES.STONE]: new THREE.MeshLambertMaterial({ color: 0x696969 }),
            [BLOCK_TYPES.WATER]: new THREE.MeshLambertMaterial({ color: 0x4169E1, transparent: true, opacity: 0.7 }),
            [BLOCK_TYPES.SAND]: new THREE.MeshLambertMaterial({ color: 0xF4A460 }),
            [BLOCK_TYPES.SNOW]: new THREE.MeshLambertMaterial({ color: 0xFFFAFA }),
            [BLOCK_TYPES.TREE]: new THREE.MeshLambertMaterial({ color: 0x228B22 })
        };

        // Network Manager
        class NetworkManager {
            constructor() {
                this.socket = null;
                this.isConnected = false;
                this.playerId = null;
                this.serverPlayers = new Map();
                this.inputSequence = 0;
                this.lastServerUpdate = 0;
                this.reconciliationBuffer = [];
                this.connectionAttempts = 0;
                this.maxConnectionAttempts = 5;
                
                this.initializeConnection();
            }
            
            initializeConnection() {
                try {
                    console.log('Initializing Socket.IO connection...');
                    
                    this.socket = io({
                        transports: ['websocket', 'polling'],
                        upgrade: true,
                        rememberUpgrade: true,
                        autoConnect: true,
                        reconnection: true,
                        reconnectionDelay: 1000,
                        reconnectionAttempts: 5,
                        timeout: 20000
                    });
                    
                    this.setupEventHandlers();
                    
                } catch (error) {
                    console.warn('Socket.IO connection failed, running in single-player mode:', error);
                    this.showConnectionStatus('Single Player', 'blue');
                    document.getElementById('network').textContent = 'Network: Single Player';
                }
            }
            
            setupEventHandlers() {
                this.socket.on('connect', () => {
                    console.log('Connected to multiplayer server');
                    this.isConnected = true;
                    gameState.isConnected = true;
                    this.connectionAttempts = 0;
                    this.showConnectionStatus('Connected', 'green');
                    document.getElementById('network').textContent = 'Network: Connected';
                });
                
                this.socket.on('disconnect', (reason) => {
                    console.log('Disconnected from server:', reason);
                    this.isConnected = false;
                    gameState.isConnected = false;
                    this.serverPlayers.clear();
                    this.showConnectionStatus('Disconnected', 'red');
                    document.getElementById('network').textContent = 'Network: Disconnected';
                });
                
                this.socket.on('connect_error', (error) => {
                    this.connectionAttempts++;
                    console.error('Connection error:', error);
                    
                    if (this.connectionAttempts >= this.maxConnectionAttempts) {
                        this.showConnectionStatus('Single Player Mode', 'blue');
                        document.getElementById('network').textContent = 'Network: Single Player';
                    } else {
                        this.showConnectionStatus(`Connecting... (${this.connectionAttempts}/${this.maxConnectionAttempts})`, 'orange');
                        document.getElementById('network').textContent = `Network: Connecting... (${this.connectionAttempts}/${this.maxConnectionAttempts})`;
                    }
                });
                
                this.socket.on('game-state', (data) => {
                    this.playerId = data.playerId;
                    gameState.playerId = data.playerId;
                    
                    data.players.forEach(playerData => {
                        if (playerData.id !== this.playerId) {
                            this.createRemotePlayer(playerData);
                        }
                    });
                    
                    console.log('Received initial game state, player ID:', this.playerId);
                });
                
                this.socket.on('game-update', (data) => {
                    this.lastServerUpdate = Date.now();
                    
                    data.players.forEach(playerData => {
                        if (playerData.id === this.playerId) {
                            this.handleServerReconciliation(playerData);
                        } else {
                            this.updateRemotePlayer(playerData);
                        }
                    });
                    
                    gameState.lastUIUpdate.playerCount = data.players.length;
                    updateUI();
                });
                
                this.socket.on('player-joined', (playerData) => {
                    console.log('Player joined:', playerData.id);
                    this.createRemotePlayer(playerData);
                });
                
                this.socket.on('player-left', (playerId) => {
                    console.log('Player left:', playerId);
                    this.removeRemotePlayer(playerId);
                });
                
                this.socket.on('player-shot', (data) => {
                    this.handleRemoteShot(data);
                });
                
                this.socket.on('player-hit', (data) => {
                    this.handlePlayerHit(data);
                });
                
                this.socket.on('player-reloaded', (data) => {
                    gameState.ammo = data.ammo;
                    gameState.totalAmmo = data.totalAmmo;
                    updateUI();
                });
            }
            
            sendPlayerInput(inputState, playerPosition, playerRotation) {
                if (!this.isConnected) return;
                
                this.inputSequence++;
                const inputData = {
                    input: inputState,
                    position: {
                        x: playerPosition.x,
                        y: playerPosition.y,
                        z: playerPosition.z
                    },
                    rotation: {
                        x: playerRotation.x,
                        y: playerRotation.y,
                        z: playerRotation.z
                    },
                    sequence: this.inputSequence,
                    timestamp: Date.now()
                };
                
                this.reconciliationBuffer.push({
                    sequence: this.inputSequence,
                    input: inputState,
                    timestamp: Date.now(),
                    position: { ...inputData.position }
                });
                
                if (this.reconciliationBuffer.length > 60) {
                    this.reconciliationBuffer.shift();
                }
                
                this.socket.emit('player-input', inputData);
            }
            
            sendShot(position, direction) {
                if (!this.isConnected) return;
                
                const velocity = {
                    x: direction.x * CONFIG.BULLET_SPEED,
                    y: direction.y * CONFIG.BULLET_SPEED,
                    z: direction.z * CONFIG.BULLET_SPEED
                };
                
                this.socket.emit('player-shoot', {
                    position: {
                        x: position.x,
                        y: position.y,
                        z: position.z
                    },
                    velocity: velocity,
                    timestamp: Date.now()
                });
            }
            
            sendReload() {
                if (!this.isConnected) return;
                this.socket.emit('player-reload');
            }
            
            handleServerReconciliation(serverPlayer) {
                const serverSequence = serverPlayer.inputSequence;
                const reconciliationEntry = this.reconciliationBuffer.find(
                    entry => entry.sequence === serverSequence
                );
                
                if (reconciliationEntry) {
                    const positionDiff = Math.abs(
                        reconciliationEntry.position.x - serverPlayer.position.x +
                        reconciliationEntry.position.y - serverPlayer.position.y +
                        reconciliationEntry.position.z - serverPlayer.position.z
                    );
                    
                    if (positionDiff > 0.5) {
                        const currentPos = controls.getObject().position;
                        currentPos.lerp(
                            new THREE.Vector3(
                                serverPlayer.position.x,
                                serverPlayer.position.y,
                                serverPlayer.position.z
                            ),
                            0.3
                        );
                    }
                    
                    this.reconciliationBuffer = this.reconciliationBuffer.filter(
                        entry => entry.sequence > serverSequence
                    );
                }
            }
            
            createRemotePlayer(playerData) {
                if (this.serverPlayers.has(playerData.id)) return;
                
                const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
                const material = new THREE.MeshLambertMaterial({ 
                    color: this.getPlayerColor(playerData.id) 
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(
                    playerData.position.x,
                    playerData.position.y,
                    playerData.position.z
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                const nameTag = this.createNameTag(playerData.id);
                mesh.add(nameTag);
                
                scene.add(mesh);
                
                const remotePlayer = {
                    id: playerData.id,
                    mesh: mesh,
                    targetPosition: { ...playerData.position },
                    targetRotation: { ...playerData.rotation },
                    health: playerData.health,
                    isAlive: playerData.isAlive,
                    interpolationBuffer: []
                };
                
                this.serverPlayers.set(playerData.id, remotePlayer);
            }
            
            updateRemotePlayer(playerData) {
                const remotePlayer = this.serverPlayers.get(playerData.id);
                if (!remotePlayer) {
                    this.createRemotePlayer(playerData);
                    return;
                }
                
                remotePlayer.interpolationBuffer.push({
                    position: { ...playerData.position },
                    rotation: { ...playerData.rotation },
                    timestamp: Date.now()
                });
                
                if (remotePlayer.interpolationBuffer.length > 10) {
                    remotePlayer.interpolationBuffer.shift();
                }
                
                remotePlayer.health = playerData.health;
                remotePlayer.isAlive = playerData.isAlive;
                remotePlayer.mesh.visible = playerData.isAlive;
            }
            
            interpolateRemotePlayers() {
                const now = Date.now();
                const interpolationDelay = 100;
                
                this.serverPlayers.forEach(remotePlayer => {
                    if (!remotePlayer.isAlive || remotePlayer.interpolationBuffer.length < 2) return;
                    
                    const targetTime = now - interpolationDelay;
                    let olderFrame = null;
                    let newerFrame = null;
                    
                    for (let i = 0; i < remotePlayer.interpolationBuffer.length - 1; i++) {
                        if (remotePlayer.interpolationBuffer[i].timestamp <= targetTime &&
                            remotePlayer.interpolationBuffer[i + 1].timestamp >= targetTime) {
                            olderFrame = remotePlayer.interpolationBuffer[i];
                            newerFrame = remotePlayer.interpolationBuffer[i + 1];
                            break;
                        }
                    }
                    
                    if (olderFrame && newerFrame) {
                        const timeDiff = newerFrame.timestamp - olderFrame.timestamp;
                        const alpha = timeDiff > 0 ? (targetTime - olderFrame.timestamp) / timeDiff : 0;
                        
                        remotePlayer.mesh.position.lerpVectors(
                            new THREE.Vector3(
                                olderFrame.position.x,
                                olderFrame.position.y,
                                olderFrame.position.z
                            ),
                            new THREE.Vector3(
                                newerFrame.position.x,
                                newerFrame.position.y,
                                newerFrame.position.z
                            ),
                            alpha
                        );
                    }
                    
                    remotePlayer.interpolationBuffer = remotePlayer.interpolationBuffer.filter(
                        frame => now - frame.timestamp < 500
                    );
                });
            }
            
            removeRemotePlayer(playerId) {
                const remotePlayer = this.serverPlayers.get(playerId);
                if (remotePlayer) {
                    scene.remove(remotePlayer.mesh);
                    remotePlayer.mesh.geometry.dispose();
                    remotePlayer.mesh.material.dispose();
                    this.serverPlayers.delete(playerId);
                }
            }
            
            handleRemoteShot(data) {
                const bullet = bulletPool.getBullet();
                if (bullet) {
                    bullet.position.set(
                        data.position.x,
                        data.position.y,
                        data.position.z
                    );
                    
                    bullet.userData = {
                        velocity: data.velocity,
                        serverControlled: true,
                        bulletId: data.bulletId
                    };
                }
                
                weaponSystem.createMuzzleFlash(new THREE.Vector3(
                    data.position.x,
                    data.position.y,
                    data.position.z
                ));
            }
            
            handlePlayerHit(data) {
                if (data.targetId === this.playerId) {
                    gameState.health -= data.damage;
                    updateHealthBar();
                    
                    document.body.style.background = 'rgba(255,0,0,0.3)';
                    setTimeout(() => {
                        document.body.style.background = 'transparent';
                    }, 200);
                }
                
                this.createHitEffect(new THREE.Vector3(
                    data.position.x,
                    data.position.y,
                    data.position.z
                ), 0xff0000);
            }
            
            getPlayerColor(playerId) {
                let hash = 0;
                for (let i = 0; i < playerId.length; i++) {
                    hash = playerId.charCodeAt(i) + ((hash << 5) - hash);
                }
                const hue = Math.abs(hash % 360);
                return new THREE.Color(`hsl(${hue}, 70%, 50%)`);
            }
            
            createNameTag(playerId) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, 256, 64);
                
                context.fillStyle = 'white';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(playerId.substring(0, 8), 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                
                sprite.position.set(0, 1.5, 0);
                sprite.scale.set(2, 0.5, 1);
                
                return sprite;
            }
            
            showConnectionStatus(status, color) {
                const statusEl = document.getElementById('connection-status');
                statusEl.textContent = status;
                statusEl.style.backgroundColor = color;
                statusEl.style.opacity = '1';
                
                if (color === 'green') {
                    setTimeout(() => {
                        statusEl.style.opacity = '0';
                    }, 3000);
                }
            }
            
            createHitEffect(position, color) {
                const particleCount = 12;
                const particles = new THREE.Group();
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.02, 4, 4),
                        new THREE.MeshBasicMaterial({ color: color })
                    );
                    
                    particle.position.copy(position);
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 5 + 2,
                        (Math.random() - 0.5) * 10
                    );
                    
                    particles.add(particle);
                }
                
                scene.add(particles);
                
                const animateParticles = () => {
                    let activeParticles = 0;
                    
                    particles.children.forEach(particle => {
                        if (particle.userData.life === undefined) particle.userData.life = 1.0;
                        
                        if (particle.userData.life > 0) {
                            particle.velocity.y -= 15 * 0.016;
                            particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
                            particle.userData.life -= 0.05;
                            particle.material.opacity = particle.userData.life;
                            activeParticles++;
                        }
                    });
                    
                    if (activeParticles > 0) {
                        requestAnimationFrame(animateParticles);
                    } else {
                        scene.remove(particles);
                        particles.children.forEach(particle => {
                            particle.geometry.dispose();
                            particle.material.dispose();
                        });
                    }
                };
                
                animateParticles();
            }
            
            update() {
                if (this.isConnected) {
                    this.interpolateRemotePlayers();
                }
            }
        }

        // Perlin Noise Implementation
        class PerlinNoise {
            constructor(seed = 12345) {
                this.seed = seed;
                this.permutation = this.generatePermutation();
            }

            generatePermutation() {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                
                let rng = this.seed;
                for (let i = 255; i > 0; i--) {
                    rng = (rng * 9301 + 49297) % 233280;
                    const j = Math.floor((rng / 233280) * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }
                
                return p.concat(p);
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y, z = 0) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                
                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                
                const A = this.permutation[X] + Y;
                const AA = this.permutation[A] + Z;
                const AB = this.permutation[A + 1] + Z;
                const B = this.permutation[X + 1] + Y;
                const BA = this.permutation[B] + Z;
                const BB = this.permutation[B + 1] + Z;
                
                return this.lerp(w,
                    this.lerp(v,
                        this.lerp(u, this.grad(this.permutation[AA], x, y, z),
                                     this.grad(this.permutation[BA], x - 1, y, z)),
                        this.lerp(u, this.grad(this.permutation[AB], x, y - 1, z),
                                     this.grad(this.permutation[BB], x - 1, y - 1, z))),
                    this.lerp(v,
                        this.lerp(u, this.grad(this.permutation[AA + 1], x, y, z - 1),
                                     this.grad(this.permutation[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.permutation[AB + 1], x, y - 1, z - 1),
                                     this.grad(this.permutation[BB + 1], x - 1, y - 1, z - 1))));
            }

            octaveNoise(x, y, octaves = 4, persistence = 0.5, scale = 0.01) {
                let value = 0;
                let amplitude = 1;
                let frequency = scale;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    value += this.noise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }

                return value / maxValue;
            }
        }

        // Voxel World Generation
        class VoxelWorld {
            constructor() {
                this.chunks = new Map();
                this.blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            }

            getBlockType(x, y, z) {
                const heightNoise = noise.octaveNoise(x, z, 4, 0.5, 0.01);
                const moistureNoise = noise.octaveNoise(x, z, 3, 0.6, 0.02);
                const temperatureNoise = noise.octaveNoise(x, z, 2, 0.4, 0.015);
                
                const baseHeight = Math.floor(20 + heightNoise * 20);
                const waterLevel = 15;
                
                if (y > baseHeight + 10) return BLOCK_TYPES.AIR;
                if (y <= waterLevel && y > baseHeight) return BLOCK_TYPES.WATER;
                if (y <= 5) return BLOCK_TYPES.STONE;
                
                if (y <= baseHeight) {
                    if (temperatureNoise > 0.3 && moistureNoise < -0.2) return BLOCK_TYPES.SAND;
                    if (temperatureNoise < -0.3) return BLOCK_TYPES.SNOW;
                    if (y === baseHeight) return BLOCK_TYPES.GRASS;
                    if (y > baseHeight - 3) return BLOCK_TYPES.DIRT;
                    return BLOCK_TYPES.STONE;
                }
                
                if (y === baseHeight + 1 && Math.random() < 0.01 && temperatureNoise > -0.2) {
                    return BLOCK_TYPES.TREE;
                }
                
                return BLOCK_TYPES.AIR;
            }

            generateChunk(chunkX, chunkZ) {
                const chunkKey = `${chunkX},${chunkZ}`;
                if (this.chunks.has(chunkKey)) return this.chunks.get(chunkKey);

                const chunk = new THREE.Group();
                const instances = new Map();

                Object.keys(BLOCK_TYPES).forEach(type => {
                    const blockType = BLOCK_TYPES[type];
                    if (blockType !== BLOCK_TYPES.AIR) {
                        instances.set(blockType, []);
                    }
                });

                for (let x = 0; x < CONFIG.CHUNK_SIZE; x++) {
                    for (let z = 0; z < CONFIG.CHUNK_SIZE; z++) {
                        for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                            const worldX = chunkX * CONFIG.CHUNK_SIZE + x;
                            const worldZ = chunkZ * CONFIG.CHUNK_SIZE + z;
                            const blockType = this.getBlockType(worldX, y, worldZ);
                            
                            if (blockType !== BLOCK_TYPES.AIR) {
                                const matrix = new THREE.Matrix4();
                                matrix.setPosition(worldX, y, worldZ);
                                instances.get(blockType).push(matrix);
                            }
                        }
                    }
                }

                instances.forEach((matrices, blockType) => {
                    if (matrices.length > 0) {
                        const instancedMesh = new THREE.InstancedMesh(
                            this.blockGeometry,
                            blockMaterials[blockType],
                            matrices.length
                        );
                        
                        matrices.forEach((matrix, i) => {
                            instancedMesh.setMatrixAt(i, matrix);
                        });
                        
                        instancedMesh.instanceMatrix.needsUpdate = true;
                        instancedMesh.castShadow = true;
                        instancedMesh.receiveShadow = true;
                        chunk.add(instancedMesh);
                    }
                });

                chunk.userData = { chunkKey, instances };
                this.chunks.set(chunkKey, chunk);
                return chunk;
            }

            disposeChunk(chunkKey) {
                const chunk = this.chunks.get(chunkKey);
                if (chunk) {
                    chunk.children.forEach(child => {
                        if (child.dispose) child.dispose();
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    this.chunks.delete(chunkKey);
                }
            }
        }

        // Bullet Pool
        class BulletPool {
            constructor(size = 100) {
                this.pool = [];
                this.active = [];
                
                for (let i = 0; i < size; i++) {
                    const mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 6),
                        new THREE.MeshBasicMaterial({ color: 0xffff00 })
                    );
                    mesh.visible = false;
                    mesh.userData = { pooled: true };
                    scene.add(mesh);
                    this.pool.push(mesh);
                }
            }

            getBullet() {
                if (this.pool.length > 0) {
                    const mesh = this.pool.pop();
                    mesh.visible = true;
                    mesh.userData = { pooled: false };
                    this.active.push(mesh);
                    return mesh;
                }
                return null;
            }

            returnBullet(mesh) {
                if (!mesh || mesh.userData.pooled) return;
                
                mesh.visible = false;
                mesh.userData = { pooled: true };
                mesh.position.set(0, -10000, 0);
                
                const index = this.active.indexOf(mesh);
                if (index > -1) {
                    this.active.splice(index, 1);
                    this.pool.push(mesh);
                }
            }
        }

        // Weapon System
        class WeaponSystem {
            constructor() {
                this.lastShot = 0;
                this.isReloading = false;
                this.createWeaponMesh();
            }
            
            createWeaponMesh() {
                const weaponGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.8);
                const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                this.weaponMesh = new THREE.Mesh(weaponGeometry, weaponMaterial);
                
                this.weaponMesh.position.set(0.3, -0.2, -0.5);
                this.weaponMesh.rotation.y = THREE.MathUtils.degToRad(5);
                
                camera.add(this.weaponMesh);
            }
            
            canShoot() {
                return !this.isReloading && 
                       gameState.ammo > 0 && 
                       Date.now() - this.lastShot > 150;
            }
            
            fireWeapon() {
                if (!this.canShoot()) return false;
                
                this.lastShot = Date.now();
                
                const weaponWorldPosition = new THREE.Vector3();
                this.weaponMesh.getWorldPosition(weaponWorldPosition);
                
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                // Client-side shooting
                const bullet = new Bullet(weaponWorldPosition.clone(), direction, CONFIG.BULLET_DAMAGE, 'player');
                if (bullet.mesh) {
                    gameState.bullets.push(bullet);
                }
                
                // Server-side shooting
                if (networkManager && networkManager.isConnected) {
                    networkManager.sendShot(weaponWorldPosition, direction);
                } else {
                    // Single player mode
                    gameState.ammo--;
                }
                
                // Weapon recoil
                this.weaponMesh.position.z -= 0.05;
                setTimeout(() => {
                    this.weaponMesh.position.z += 0.05;
                }, 50);
                
                this.createMuzzleFlash(weaponWorldPosition);
                updateUI();
                return true;
            }
            
            createMuzzleFlash(position) {
                const flash = new THREE.PointLight(0xffff00, 2, 10);
                flash.position.copy(position);
                scene.add(flash);
                setTimeout(() => scene.remove(flash), 50);
            }
            
            reload() {
                if (this.isReloading || gameState.totalAmmo <= 0 || gameState.ammo === CONFIG.AMMO_CAPACITY) return;
                
                this.isReloading = true;
                
                if (networkManager && networkManager.isConnected) {
                    networkManager.sendReload();
                } else {
                    // Single player reload
                    setTimeout(() => {
                        const needed = CONFIG.AMMO_CAPACITY - gameState.ammo;
                        const available = Math.min(needed, gameState.totalAmmo);
                        
                        gameState.ammo += available;
                        gameState.totalAmmo -= available;
                        this.isReloading = false;
                        updateUI();
                    }, 2000);
                }
            }
        }

        // Bullet System
        class Bullet {
            constructor(position, direction, damage, owner = 'player') {
                this.mesh = bulletPool.getBullet();
                if (!this.mesh) return null;
                
                this.mesh.position.copy(position);
                this.velocity = direction.clone().multiplyScalar(CONFIG.BULLET_SPEED);
                this.life = 5;
                this.damage = damage;
                this.owner = owner;
            }

            update(delta) {
                if (!this.mesh) return false;
                
                this.velocity.y += CONFIG.BULLET_GRAVITY * delta;
                
                const deltaVelocity = this.velocity.clone().multiplyScalar(delta);
                this.mesh.position.add(deltaVelocity);
                
                if (this.mesh.position.y < -20 || this.mesh.position.y > CONFIG.WORLD_HEIGHT + 50) {
                    this.destroy();
                    return false;
                }
                
                this.life -= delta;
                if (this.life <= 0) {
                    this.destroy();
                    return false;
                }
                
                return true;
            }

            destroy() {
                if (this.mesh) {
                    bulletPool.returnBullet(this.mesh);
                    this.mesh = null;
                }
                const index = gameState.bullets.indexOf(this);
                if (index > -1) {
                    gameState.bullets.splice(index, 1);
                }
            }
        }

        // Initialize systems
        const noise = new PerlinNoise(42);
        const bulletPool = new BulletPool(100);
        const voxelWorld = new VoxelWorld();
        const weaponSystem = new WeaponSystem();
        const networkManager = new NetworkManager();

        // Movement
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            canJump: false
        };

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Event Handlers
        const onKeyDown = function(event) {
            switch(event.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space':
                    event.preventDefault();
                    if (moveState.canJump) {
                        velocity.y += CONFIG.JUMP_VELOCITY;
                        moveState.canJump = false;
                    }
                    break;
                case 'KeyR':
                    weaponSystem.reload();
                    break;
            }
        };

        const onKeyUp = function(event) {
            switch(event.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        };

        const onMouseDown = function(event) {
            if (controls.isLocked && event.button === 0) {
                weaponSystem.fireWeapon();
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('mousedown', onMouseDown);

        renderer.domElement.addEventListener('click', () => {
            if (!controls.isLocked) {
                controls.lock();
            }
        });

        // Game Functions
        function updateHealthBar() {
            const healthPercent = Math.max(0, gameState.health / CONFIG.MAX_HEALTH);
            document.getElementById('health-fill').style.width = `${healthPercent * 100}%`;
            
            if (gameState.health <= 0) {
                alert('Game Over! Final Score: ' + gameState.score);
                location.reload();
            }
        }

        function updateUI() {
            const state = gameState.lastUIUpdate;
            
            if (state.ammo !== gameState.ammo) {
                document.getElementById('ammo').textContent = gameState.ammo;
                state.ammo = gameState.ammo;
            }
            
            if (state.totalAmmo !== gameState.totalAmmo) {
                document.getElementById('total-ammo').textContent = gameState.totalAmmo;
                state.totalAmmo = gameState.totalAmmo;
            }
            
            if (state.playerCount !== gameState.lastUIUpdate.playerCount) {
                document.getElementById('player-count').textContent = gameState.lastUIUpdate.playerCount;
                state.playerCount = gameState.lastUIUpdate.playerCount;
            }
            
            if (state.score !== gameState.score) {
                document.getElementById('score').textContent = gameState.score;
                state.score = gameState.score;
            }
        }

        let chunkUpdateCounter = 0;
        function updateChunks() {
            chunkUpdateCounter++;
            if (chunkUpdateCounter < 5) return;
            chunkUpdateCounter = 0;
            
            const playerChunkX = Math.floor(camera.position.x / CONFIG.CHUNK_SIZE);
            const playerChunkZ = Math.floor(camera.position.z / CONFIG.CHUNK_SIZE);
            
            const requiredChunks = new Set();
            
            for (let x = playerChunkX - CONFIG.RENDER_DISTANCE; x <= playerChunkX + CONFIG.RENDER_DISTANCE; x++) {
                for (let z = playerChunkZ - CONFIG.RENDER_DISTANCE; z <= playerChunkZ + CONFIG.RENDER_DISTANCE; z++) {
                    const chunkKey = `${x},${z}`;
                    requiredChunks.add(chunkKey);
                    
                    if (!gameState.loadedChunks.has(chunkKey)) {
                        const chunk = voxelWorld.generateChunk(x, z);
                        scene.add(chunk);
                        gameState.loadedChunks.add(chunkKey);
                    }
                }
            }
            
            for (let chunkKey of gameState.loadedChunks) {
                if (!requiredChunks.has(chunkKey)) {
                    const chunk = voxelWorld.chunks.get(chunkKey);
                    if (chunk) {
                        scene.remove(chunk);
                        voxelWorld.disposeChunk(chunkKey);
                        gameState.loadedChunks.delete(chunkKey);
                    }
                }
            }
        }

        let frameCount = 0;
        let lastTime = performance.now();

        function updateStats() {
            const currentTime = performance.now();
            frameCount++;
            
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                document.getElementById('chunks').textContent = `Chunks: ${gameState.loadedChunks.size}`;
                document.getElementById('position').textContent = 
                    `Position: ${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
                
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function getTerrainHeight(x, z) {
            const key = `${Math.floor(x)},${Math.floor(z)}`;
            if (gameState.terrainCache.has(key)) {
                return gameState.terrainCache.get(key);
            }
            
            for (let y = CONFIG.WORLD_HEIGHT - 1; y >= 0; y--) {
                if (voxelWorld.getBlockType(Math.floor(x), y, Math.floor(z)) !== BLOCK_TYPES.AIR) {
                    gameState.terrainCache.set(key, y + 1);
                    return y + 1;
                }
            }
            gameState.terrainCache.set(key, 0);
            return 0;
        }

        // Initialize world
        async function initializeWorld() {
            const loadingEl = document.getElementById('loading');
            const progressEl = document.getElementById('progress');
            
            const totalChunks = (CONFIG.RENDER_DISTANCE * 2 + 1) ** 2;
            let loadedChunks = 0;
            
            console.log('Generating world chunks...');
            
            for (let x = -CONFIG.RENDER_DISTANCE; x <= CONFIG.RENDER_DISTANCE; x++) {
                for (let z = -CONFIG.RENDER_DISTANCE; z <= CONFIG.RENDER_DISTANCE; z++) {
                    const chunk = voxelWorld.generateChunk(x, z);
                    scene.add(chunk);
                    gameState.loadedChunks.add(`${x},${z}`);
                    
                    loadedChunks++;
                    const progress = Math.round((loadedChunks / totalChunks) * 100);
                    progressEl.textContent = `${progress}%`;
                    
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            const playerHeight = voxelWorld.getBlockType(0, 30, 0) !== BLOCK_TYPES.AIR ? 30 : 40;
            camera.position.set(0, playerHeight + CONFIG.PLAYER_HEIGHT, 0);
            
            loadingEl.style.display = 'none';
            updateUI();
            
            console.log('✅ World initialized with', gameState.loadedChunks.size, 'chunks');
        }

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            const delta = clock.getDelta();
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                velocity.y += CONFIG.GRAVITY * delta;

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize();

                if (moveState.forward || moveState.backward) {
                    velocity.z = -direction.z * CONFIG.PLAYER_SPEED;
                }

                if (moveState.left || moveState.right) {
                    velocity.x = -direction.x * CONFIG.PLAYER_SPEED;
                }

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                const playerObject = controls.getObject();
                const oldY = playerObject.position.y;
                playerObject.position.y += velocity.y * delta;

                const terrainHeight = getTerrainHeight(playerObject.position.x, playerObject.position.z);
                if (playerObject.position.y <= terrainHeight + CONFIG.PLAYER_HEIGHT) {
                    playerObject.position.y = terrainHeight + CONFIG.PLAYER_HEIGHT;
                    velocity.y = 0;
                    moveState.canJump = true;
                }

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                // Send input to server
                if (networkManager && networkManager.isConnected) {
                    networkManager.sendPlayerInput(moveState, playerObject.position, camera.rotation);
                }
            }

            // Update bullets
            gameState.bullets = gameState.bullets.filter(bullet => bullet.update(delta));

            // Update networking
            if (networkManager) {
                networkManager.update();
            }

            updateChunks();
            updateStats();
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        // Initialize the game
        console.log('🎮 Initializing Multiplayer Voxel FPS...');
        initializeWorld().then(() => {
            animate();
            console.log('🚀 Game ready!');
            console.log('🌐 Multiplayer: Socket.IO with WebSocket transport');
            console.log('🎯 Controls: Click to lock, WASD to move, mouse to look, click to shoot, R to reload');
        });

    </script>
</body>
</html>
